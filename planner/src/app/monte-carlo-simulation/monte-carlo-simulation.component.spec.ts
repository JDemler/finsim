import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { MonteCarloSimulationComponent } from './monte-carlo-simulation.component';
import { Plan } from '../plan/plan.component'; // Assuming Plan is exported here
import { NO_ERRORS_SCHEMA } from '@angular/core';

describe('MonteCarloSimulationComponent', () => {
  let component: MonteCarloSimulationComponent;
  let fixture: ComponentFixture<MonteCarloSimulationComponent>;
  let httpMock: HttpTestingController;

  const mockCsvData = `Date,Price,Open,High,Low,Vol.,Change %
"Jul 17, 2024","430.00","430.00","430.00","430.00",,"0.00%"
"Jul 16, 2024","430.00","429.72","430.19","429.57",,"0.07%"
"Jul 15, 2024","429.70","429.01","430.12","428.78",,"0.16%"`; // Minimal CSV for loading

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [
        FormsModule,
        CommonModule,
        MonteCarloSimulationComponent, // Import the standalone component
        HttpClientTestingModule
      ],
      // No declarations needed for standalone components if they import their dependencies.
      schemas: [NO_ERRORS_SCHEMA] // To ignore BaseChartDirective if not deeply testing chart rendering
    }).compileComponents();

    fixture = TestBed.createComponent(MonteCarloSimulationComponent);
    component = fixture.componentInstance;
    httpMock = TestBed.inject(HttpTestingController);

    // Mock the historical data loading process to avoid actual HTTP calls in most tests
    // You can spyOn(component, 'loadHistoricalData').and.callFake(() => { ... });
    // or let it run and mock the HTTP call.
    const req = httpMock.expectOne('assets/ftse-all-world.csv');
    req.flush(mockCsvData);

    // Wait for data to be loaded and processed
    await fixture.whenStable();
    fixture.detectChanges();
  });

  afterEach(() => {
    httpMock.verify(); // Verify that no unmatched requests are outstanding
  });

  it('should create and load historical data', () => {
    expect(component).toBeTruthy();
    expect((component as any).dataLoaded).toBeTrue(); // Access private member for test
    expect((component as any).muDaily).toBeGreaterThan(0); // Or some expected value based on mock
    expect((component as any).sigmaDaily).toBeGreaterThan(0);
  });

  // Helper function to wait for simulation to complete
  async function runAndCompleteSimulation() {
    component.runSimulation(); // This is async
    await fixture.whenStable(); // Wait for promises in runSimulation
    tick(); // Process any microtasks like progress updates
    fixture.detectChanges();
  }

  describe('totalYears Calculation (implicitly tested via runSimulation effects)', () => {
    it('should default to 1 year if no plans are provided', fakeAsync(() => {
      component.plans = [];
      component.initialInvestment = 1000;
      spyOn(component, 'updateChart').and.callThrough();

      runAndCompleteSimulation();

      // Check labels generated by updateChart, which depends on totalYears
      const expectedLabelsLength = Math.floor(1 * 12) + 1; // 1 year
      expect(component.lineChartData.labels?.length).toBe(expectedLabelsLength);
    }));

    it('should calculate totalYears based on a single plan', fakeAsync(() => {
      component.plans = [{ id: 1, type: 'salary', amount: 50000, startYear: 0, duration: 5, yearlyIncrease: 2 }];
      spyOn(component, 'updateChart').and.callThrough();

      runAndCompleteSimulation();

      const expectedYears = 5;
      const expectedLabelsLength = Math.floor(expectedYears * 12) + 1;
      expect(component.lineChartData.labels?.length).toBe(expectedLabelsLength);
    }));

    it('should calculate totalYears based on the maximum of multiple plans', fakeAsync(() => {
      component.plans = [
        { id: 1, type: 'salary', amount: 50000, startYear: 0, duration: 5 },
        { id: 2, type: 'savings', amount: 200, startYear: 2, duration: 10 } // Ends at year 2+10=12
      ];
      spyOn(component, 'updateChart').and.callThrough();

      runAndCompleteSimulation();

      const expectedYears = 12;
      const expectedLabelsLength = Math.floor(expectedYears * 12) + 1;
      expect(component.lineChartData.labels?.length).toBe(expectedLabelsLength);
    }));
  });

  describe('Simulation Logic with Plan Inputs', () => {
    beforeEach(() => {
      // Ensure a small number of simulations for faster tests
      component.numSimulations = 1;
      // Mock randomNormal to return 0 for deterministic results (no market influence)
      spyOn(component, 'randomNormal').and.returnValue(0);
    });

    it('Scenario: Initial Investment Only', fakeAsync(() => {
      component.initialInvestment = 10000;
      component.plans = [];

      runAndCompleteSimulation();

      expect(component.result).not.toBeNull();
      expect(component.result?.paths.length).toBe(1);
      // With randomNormal = 0, and no plans, final value should be initial investment
      expect(component.result?.finalValues[0]).toBeCloseTo(10000);
    }));

    it('Scenario: Salary Plan Affects Final Value', fakeAsync(() => {
      component.initialInvestment = 10000;
      // Salary: 25200/year (100/day for 252 days) for 1 year
      component.plans = [{ id: 1, type: 'salary', amount: 25200, startYear: 0, duration: 1, yearlyIncrease: 0 }];

      runAndCompleteSimulation();

      expect(component.result).not.toBeNull();
      // Expected: 10000 (initial) + 25200 (salary) = 35200
      // (assuming daily salary is added before daily return, and daily return is 0)
      expect(component.result?.finalValues[0]).toBeCloseTo(35200);
    }));

    it('Scenario: Fixed Savings Plan Affects Final Value', fakeAsync(() => {
      component.initialInvestment = 10000;
      // Savings: 2520/year (10/day) for 1 year
      component.plans = [{ id: 1, type: 'savings', amount: 2520, startYear: 0, duration: 1, isPercentage: false }];

      runAndCompleteSimulation();

      expect(component.result).not.toBeNull();
      // Expected: 10000 (initial) + 2520 (savings) = 12520
      expect(component.result?.finalValues[0]).toBeCloseTo(12520);
    }));

    it('Scenario: Withdrawal Plan Affects Final Value', fakeAsync(() => {
      component.initialInvestment = 10000;
      // Withdrawal: 2520/year (10/day) for 1 year
      component.plans = [{ id: 1, type: 'withdrawal', amount: 2520, startYear: 0, duration: 1 }];

      runAndCompleteSimulation();

      expect(component.result).not.toBeNull();
      // Expected: 10000 (initial) - 2520 (withdrawal) = 7480
      expect(component.result?.finalValues[0]).toBeCloseTo(7480);
    }));

    it('Scenario: Percentage Savings Plan Affects Final Value (based on Salary)', fakeAsync(() => {
        component.initialInvestment = 10000;
        component.plans = [
            { id: 1, type: 'salary', amount: 25200, startYear: 0, duration: 1, yearlyIncrease: 0 }, // 100/day
            { id: 2, type: 'savings', amount: 10, startYear: 0, duration: 1, isPercentage: true } // 10% of salary
        ];

        runAndCompleteSimulation();

        expect(component.result).not.toBeNull();
        // Salary: 25200. Savings: 10% of 25200 = 2520.
        // Expected: 10000 (initial) + 25200 (salary) + 2520 (savings) = 37720
        expect(component.result?.finalValues[0]).toBeCloseTo(37720);
    }));
  });

  describe('Chart Update Logic', () => {
    it('updateChart should be called after simulation', fakeAsync(() => {
      spyOn(component, 'updateChart').and.callThrough();
      component.initialInvestment = 1000;
      component.plans = [];

      runAndCompleteSimulation();

      expect(component.updateChart).toHaveBeenCalled();
    }));
  });

});
